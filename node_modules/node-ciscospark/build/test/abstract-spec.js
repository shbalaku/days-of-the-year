'use strict';
/* eslint-env mocha */
/* eslint-disable no-unused-expressions */

var Spark = require('../src');
var SparkBase = require('../src/CiscoSpark');
var chai = require('chai');
chai.use(require('chai-string'));
var expect = chai.expect;
var async = require('async');

/** @test {CiscoSpark} */
describe('CiscoSpark.abstractMethods', function () {
  /** @test {CiscoSpark#request} */
  it('should get token from Environment Variable', function (done) {
    process.env.CISCOSPARK_ACCESS_TOKEN = '***Test Token***';
    process.env.CISCOSPARK_USER_AGENT = '***Test Agent***';
    var sparkx = new SparkBase();
    sparkx.accessToken = null;
    sparkx.userAgent = null;
    var spark = new SparkBase(sparkx);
    spark.apiUrl = 'http://localhost/dev/null';
    expect(spark.accessToken).to.be.equals(process.env.CISCOSPARK_ACCESS_TOKEN);
    expect(spark.userAgent).to.be.equals(process.env.CISCOSPARK_USER_AGENT);
    spark.request({ method: 'GET' }, function () {
      done();
    });
  });

  it('should error if ApiUrl is not set', function (done) {
    var spark = new Spark();
    var tasks = [function (cb) {
      spark.list(null, function (err, response) {
        expect(err).to.be.instanceOf(Error);
        expect(response).to.be.not.ok;
        cb();
      });
    }, function (cb) {
      spark.create(null, function (err, response) {
        expect(err).to.be.instanceOf(Error);
        expect(response).to.be.not.ok;
        cb();
      });
    }, function (cb) {
      spark.get(null, function (err, response) {
        expect(err).to.be.instanceOf(Error);
        expect(response).to.be.not.ok;
        cb();
      });
    }, function (cb) {
      spark.update(0, null, function (err, response) {
        expect(err).to.be.instanceOf(Error);
        expect(response).to.be.not.ok;
        cb();
      });
    }, function (cb) {
      spark.delete(null, function (err, response) {
        expect(err).to.be.instanceOf(Error);
        expect(response).to.be.not.ok;
        cb();
      });
    }];
    async.parallel(tasks, done);
  });

  it('should error if Params is not set', function (done) {
    var spark = new SparkBase('***Test Token***', '***Test Agent***', '***Test URL***');
    spark.requestCallback = function (options, callback) {
      return callback(null, {
        options: options,
        timestamp: Date.now()
      });
    };
    var tasks = [function (cb) {
      spark.list(null, function (err, response) {
        expect(err).to.be.not.ok;
        cb();
      });
    }, function (cb) {
      spark.create(null, function (err, response) {
        expect(err).to.be.instanceOf(Error);
        cb();
      });
    }, function (cb) {
      spark.get(null, function (err, response) {
        expect(err).to.be.instanceOf(Error);
        cb();
      });
    }, function (cb) {
      spark.update(0, null, function (err, response) {
        expect(err).to.be.instanceOf(Error);
        cb();
      });
    }, function (cb) {
      spark.delete(null, function (err, response) {
        expect(err).to.be.instanceOf(Error);
        cb();
      });
    }];
    async.parallel(tasks, done);
  });

  it('should detect arguments correctly', function (done) {
    var spark = new SparkBase('***Test Token***', '***Test Agent***', '***Test URL***');
    spark.requestCallback = function (options, callback) {
      return callback(null, {
        options: options,
        timestamp: Date.now()
      });
    };
    spark.idName = 'testId';
    var testId = '*** Test Id ***';
    var testValue = '' + Date.now();
    var tasks = [function (cb) {
      spark.get({ id: testId }, function (err, response) {
        expect(err).to.be.not.ok;
        expect(response.options.url).to.endsWith(testId);
        cb();
      });
    }, function (cb) {
      spark.update({ 'testId': testId, 'key': testValue }, function (err, response) {
        expect(err).to.be.not.ok;
        expect(response.options.url).to.endsWith(testId);
        expect(response.options.json.key).to.be.equals(testValue);
        cb();
      });
    }, function (cb) {
      spark.update(function (err, response) {
        expect(err).to.be.not.ok;
        expect(response.options.url).to.endsWith(testId);
        expect(response.options.json.key).to.be.equals(testValue);
        cb();
      }, { key: testValue }, testId);
    }];
    async.parallel(tasks, done);
  });
});